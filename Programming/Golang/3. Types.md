# Structures
![[structure-definition.png]]
### Defining a structure
```go
type Sample struct {
	field string
	a, b int
}
```

### Instantiating a structure
```go
data := Sample{"word", 1, 2}

data := Sample{
	field: "word",
	a:     1,
	b:     2,
}
```
- In the first way, we have to assign each field ***in order***

### Default values
```go
// field = ""
// a, b = 0
data := Sample{}

// field = "" 
// a = 5, b = 0
data := Sample{a: 5}
```
- Any fields not indicated during instantiation will have default values

### Accessing Fields
```go
word := data.field
a, b := data.a, data.b

data.field = "hello"
data.a = 10
data.b = 20
```
- Fields can be **read** from and **written** to

### Anonymous Structures
![[anonymous-structures-1.png]]
#### Example
```go
var sample struct {
	field string
	a, b int
}

sample.field = "hello"
sample.a = 9
```

```go
sample := struct {
	field string
	a, b int
}{
	"helo",
	1, 2,
}
```
- The main difference between the first and second way:
	- The first sample's fields will have default values if we don't supply any.
	- The second way, which use the **create-and-assign** operator, require us to declare the fields and assign them all at the same time, and we can't be missing any fields.

### Recap
![[structure-recap.png]]

### Example code
```go
package main

import "fmt"

type Coordinates struct {
	x, y int
}

type Rectangle struct {
	topLeft  Coordinates // top left
	botRight Coordinates // bottom right
}

func calculatePerimeter(rect Rectangle) int {
	rectWidth := rect.topLeft.y - rect.botRight.y
	rectLength := rect.botRight.x - rect.topLeft.x

	return (rectWidth + rectLength) * 2
}

func calculateArea(rect Rectangle) int {
	rectWidth := rect.topLeft.y - rect.botRight.y
	rectLength := rect.botRight.x - rect.topLeft.x

	return rectWidth * rectLength
}

func printInfo(rect Rectangle) {
	fmt.Println("perimeter is:", calculatePerimeter(rect))
	fmt.Println("area is:", calculateArea(rect))
}

func main() {
	r := Rectangle{
		topLeft:  Coordinates{2, 3},
		botRight: Coordinates{6, 1},
	}

	printInfo(r)
}
```

# Arrays
![[array-definition.png]]

### Visualization
![[array-visualization.png]]
- This is a visualization of arrays in memory
- Id takes 2 bytes, storeCode takes 1 byte, rate takes 4 bytes, total of 7 bytes per item
- If we want to access the third element, we begin at index 0 and skip over 14 (7 * 2) bytes

### Creating an Array
```go
var arrName [numberOfItems]itemType

// array of 3 integers with default value 0
var myArray [3]int

myArr := [3]int{1, 2, 3}

// 3 dots (...) will look over the items and set the size (here, ... = 3)
// default way to make an array âœ“
myArr := [...]int{1, 2, 3}

// fourth item will be 0
myArr := [4]int{1, 2, 3}
```
 - Elements not addressed in array initialization will be set to default values.
### Access Array Elements
```go
var myArray [3]int

myArray[0] = 7
myArray[1] = 5
myArray[2] = 4 

item1 := myArray[2]
```

### Iteration
```go
myArray := [...]int{1, 2, 3}

for i := 0; i < len(myArray); i++ {
	item := myArray[i]
	fmt.Println(item)
}
```
- Good practice to assign the element to a variable during iteration
	- Easier to read in large functions / nested loops

### Bounds
run-time error
```go
var myArray [3]int

for i:= 0; i < len(myArray); i++ {
	fmt.Println(myArray[i])
}
```

compile-time error
```go
var myArray [3]int

myArray[0] = 5

// error
myArray[3] = 4

// error
item := myArray[3]
```
- Attempting to access an element outside the bounds of an array will result in an error.

### Recap
![[array-recap.png]]