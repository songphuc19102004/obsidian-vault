# Interfaces
![[interfaces-definition.png]]

### Creation & Implementation
```go
type MyInterface interface {
	Function1()
	Function2(x int) int
}

type MyType int
func (m MyType) Function1() {}
func (m MyType) Function2(x int) int {
	return x + x
}

func execute(i MyInterface) {
	i.Function1()
}
```

### Notes
![[interfaces-notes.png]]
- Note the keyword: **"has all receiver functions"**. Because this is not a Object-Oriented language, where interfaces are implemented by putting the required functions in an object, we have to "put" all interfaces in a **"type"** (receiver functions).
- Interfaces are already ***Pointers***

### Pass by Value vs Pass by Pointers
```go
type MyType int // already implemented MyInterface

func execute(i MyInterface) {
	i.Function1()
}

m := MyType(1)
execute(m)
execute(&m)
```
- When we have an Interface as a parameter, we can either use a ***copy*** or a ***pointer***. However, if we put the parameter as a Pointer (i \*MyInterface), then we would be restricted to just use the pointer as an argument. => We want to have ***value type*** when we have Interface as a parameter.

### Pointer Receiver Implementation
![[interfaces-pointer-receiver-implementation.png]]

![[interfaces-pointer-receiver-implementation2.png]]

### Example
![[interfaces-example.png]]

### Accessing Implementing Type
![[interfaces-access-implementing-type.png]]

### Recap
![[interfaces-recap.png]]

# Error Handling
![[error-handling-definition.png]]
- Go has no Exceptions => No try catch.

### Basics
![[error-handling-basics.png]]
### Error Interface
```go
type error interface {
	Error() string
}
```
- This is the Error interface in a std library

### Implementation
```go
type DivError struct {
	a, b int
}

func (d *DivError) Error() string {
	return fmt.Sprintf("Cannot divide by zero: %d / %d", d.a, d.b)
}
```
- This is how we implement the Error interface.
- Always implement error as a ***receiver function***.
	- We always want to use ***Pointer Receiver*** when we implement error.
	- Prevents comparison problems if error is inspected. Since if we just compare the value, it will just check the data type DivError struct and will return true, even when a and b is different. By using pointers, they will compare the ***memory address***.

### Usage
![[error-handling-usage.png]]

### Working with Errors
![[error-handling-working-with-errors.png]]

![[error-handling-working-with-errors2.png]]

### Recap
![[error-handliing-recap.png]]