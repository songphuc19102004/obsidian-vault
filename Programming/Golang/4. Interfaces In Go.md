# Interfaces
![[interfaces-definition.png]]

### Creation & Implementation
```go
type MyInterface interface {
	Function1()
	Function2(x int) int
}

type MyType int
func (m MyType) Function1() {}
func (m MyType) Function2(x int) int {
	return x + x
}

func execute(i MyInterface) {
	i.Function1()
}
```

### Notes
![[interfaces-notes.png]]
- Note the keyword: **"has all receiver functions"**. Because this is not a Object-Oriented language, where interfaces are implemented by putting the required functions in an object, we have to "put" all interfaces in a **"type"** (receiver functions).
- Interfaces are already ***Pointers***

### Pass by Value vs Pass by Pointers
```go
type MyType int // already implemented MyInterface

func execute(i MyInterface) {
	i.Function1()
}

m := MyType(1)
execute(m)
execute(&m)
```
- When we have an Interface as a parameter, we can either use a ***copy*** or a ***pointer***. However, if we put the parameter as a Pointer (i \*MyInterface), then we would be restricted to just use the pointer as an argument. => We want to have ***value type*** when we have Interface as a parameter.

### Pointer Receiver Implementation
![[interfaces-pointer-receiver-implementation.png]]

![[interfaces-pointer-receiver-implementation2.png]]

### Example
![[interfaces-example.png]]

### Accessing Implementing Type
![[interfaces-access-implementing-type.png]]

### Recap
![[interfaces-recap.png]]
