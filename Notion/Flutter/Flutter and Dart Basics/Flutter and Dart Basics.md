# Folder structure

### lib folder

Contains your actual Dart code files.

→ Store Dart and Flutter code that makes up your application

### Platform names folder(android, macos, linux, web, windows)

Contains platform specific files

Typically, you don’t need to do anything with the files in those folders. Flutter will do it for you.

### build folder

We won’t work on this folder

It only contains temporary files and output files generated by Flutter as it build your app for different target platforms.

### test folder

We can write code that tests your main application.

We could define ==**automated**== test, which can be very useful

  

### Folder start with dot(.) (.dart_tool, .idea)

They hold extra configurations:

For example:

.idea: contains some extra configs for android studio

.dart_tool: contains some extra configs for some dart tooling

  

### .metada file

Manage automatically by Flutter to keep track of some internal information and metadata(siêu dữ liệu) about your project

  

### analysis_options.yaml file

It configures some Flutter and Dart tooling that’s being used by your code editor to show you warnings and errors in your code before you run the app

  

### first_app.iml file

Managed by Flutter for you

Contains more metadata and information for building your Flutter app for different platforms

  

### pubspec.yaml file

Allow you to add 3rd party packages to your Flutter projects.

You would add those packages and refer to them inside this file

# Flutter project structure

A must have function (provided by Flutter framework) in every Flutter code and to run the app is: `runApp()` . Its main job is to show UI on the screen.

A function must be in a body (between {} )

main() function is the ==**entry point**== of Dart’s Programs

```Dart
//import 'package:packageName/.../...';
import 'package:flutter/material.dart';//where runApp() resides

void main() {
	runApp();
}
```

![[/image 153.png|image 153.png]]

Flutter already added dependencies by default

  

But runApp() requires an argument (which is what should be displayed on the screen) of data type ==**Widget**== (or ==**Widget Tree**==)

![[/image 1 14.png|image 1 14.png]]

![[/image 2 13.png|image 2 13.png]]

![[/image 3 10.png|image 3 10.png]]

  

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp());
}

```

We create a Widget by using () after the Widget name (constructor)

==**MaterialApp**== is a core Widget, which we will use in almost all Flutter apps

We also need to pass another argument (using named parameters) to MaterialApp() to show something on the screen (like a ==**frame**==)

==**home**== parameter is an important parameter, you must set it for MaterialApp to define which kind of Widget (UI element) should be displayed inside of that app UI that passed to runApp()

  

## const(constant) keyword

![[/image 4 10.png|image 4 10.png]]

→ Let us reuse equal values → avoid duplication of data in memory → memory efficient

⇒ Always add const

  

  

  

# Building more complex Widget Trees

Scaffold Widget is a Widget helps us with setting up good looking screen in our app

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MaterialApp(home: Scaffold(body: Text('bello world'))));
}
```

  

If we want to center the text, we can use Center Widget

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MaterialApp(home: Scaffold(body: Center(child: Text('bello'),),),),);
}
```

Things are getting unreadable here, simply put ‘,’ between every braces (signal the editor where to best split the code) and format the document (shift alt f)

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Text('bello'),
        ),
      ),
    ),
  );
}
```

  

![[/image 5 10.png|image 5 10.png]]

  

What if we want to have a gradient instead of a color as the background color?

→ Background color requires a Color object, but gradient is not just 1 color

⇒ We need an another Widget called Container, and wrapped it around Center Widget

Container Widget is very useful for ==**configuring styling**== and ==**layout settings**==

`[Container](https://api.flutter.dev/flutter/widgets/Container-class.html)` is a widget class that allows you to ==**customize its child widget**==. Use a `Container` when you want to add padding, margins, borders, or background color, to name some of its capabilities.  
  

![[/image 6 10.png|image 6 10.png]]

It errors because Container is a Widget that does not support setting it to const → Its parent also can’t be set to const

After removing MaterialApp const

![[/image 7 9.png|image 7 9.png]]

  

Finishing gradient:

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.cyanAccent, Colors.green],
            ),
          ),
          child: const Center(
            child: Text('bello'),
          ),
        ),
      ),
    ),
  );
}
```

colors argument requires a List<Color>, the syntax to create a List is []

  

Styling text:

```Dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
                colors: [Colors.blue, Colors.cyanAccent, Colors.green],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight),
          ),
          child: const Center(
            child: Text(
              'bello world boi banana',
              style: TextStyle(
                fontSize: 30,
                color: Colors.white,
              ),
            ),
          ),
        ),
      ),
    ),
  );
}
```

# Custom Widget

As we build app, we wanna break big Widget trees apart and build our own Widget which we can use to split our code into multiple smaller, reusable, readable.

→ We create ==**Classes**==

Widgets are Objects, and Objects are Classes’ instances

```Dart
import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';

void main() {
  runApp(
    MaterialApp(
      home: Scaffold(
        body: GradientContainer(),
      ),
    ),
  );
}


class GradientContainer extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
            colors: [Colors.blue, Colors.cyanAccent, Colors.green],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight),
      ),
      child: const Center(
        child: Text(
          'bello world boi banana',
          style: TextStyle(
            fontSize: 30,
            color: Colors.white,
          ),
        ),
      ),
    );
  }
}
```

  

## Constructor function

```Dart
class GradientContainer extends StatelessWidget {
  const GradientContainer({super.key});
 }
```

const GradientContainer({super.key});

we can almost put const in front of constructor to tell that this Widget can be optimized by storing in the memory and reusable.

{super.key} shortcut for passing key object to the base class (StatelessWidget) instead of:

```Dart
const GradientContainer({key}) : super(key: key);
```

{…} is used to add named parameters to parameters

[https://dart.dev/tools/linter-rules/use_key_in_widget_constructors](https://dart.dev/tools/linter-rules/use_key_in_widget_constructors)

We should put classes in structured folders, files for better organization.

# Variable

We declare variables by using ‘var’

```Dart
var a = ‘hello’;
var b = 10;
```

==**Note**==: If we use var, we can’t put it in a const object, since the var can be changed at any time. So we have 2 options:

- declare const variable:
    
    ```Dart
    const a = Alignment.topLeft;
    const b = getAlignment();
    //Now we can use this as parameter in const object
    ```
    
- not declaring object as a constant
    
    ```Dart
    var a = ..
    var b = ..
    return Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.cyanAccent, Colors.green],
              begin: a,
              end: b,
            ),
          ),
    ```
    

  

Or we can declare with assigned data type

```Dart
DataType variable_name;
Alignment? start;
Alignment end = Alignment.topLeft;
```

  

‘final’ keyword is kind of like ‘const’, but ‘const’ provide some ==**extra information**== to Dart

const value are compile-time constant → locked in at the point of time this code is compiled instead of run time.

→ Use const instead of final

  

```Dart
import 'package:flutter/material.dart';

class StyledText extends StatelessWidget {
  const StyledText(this.text, {super.key});

  final String text;

  @override
  Widget build(BuildContext context) {
    return Text(
      text,
      style: const TextStyle(
        fontSize: 30,
        color: Colors.white,
      ),
    );
  }
}
```

Positional argument ==**must be before**== named arguments

  

# Displaying Images and Using Multiple Constructor Functions

First, create a folder assets/images to store images

![[/image 8 9.png|image 8 9.png]]

In order to use these images in our app, we have to specifiy it in the ==**pubspec.yml**== file

Scroll down untill we find a ==**commented out assets**==

![[/image 9 9.png|image 9 9.png]]

![[/image 10 8.png|image 10 8.png]]

  

```Dart
class GradientContainer extends StatelessWidget {
  const GradientContainer({super.key, required this.colors});

  const GradientContainer.bluewhite(this.colors, {super.key});
  final List<Color> colors;
  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: colors,
          begin: startAlignment,
          end: endAlignment,
        ),
      ),
      child: Center(
        child: Image.asset('assets/images/dice-images/dice-1.png'),
      ),
    );
  }
}
```

  

```Dart
const GradientContainer.bluewhite(this.colors, {super.key});
```

We can create many constructor functions to satisfy our needs

  

```Dart
child: Center(
        child: Image.asset('assets/images/dice-images/dice-1.png'),
      ),
```

We have to remove const from Center() because Image is dynamic and not guaranteed to be there

# Buttons and Use Functions as Values

## Row and Column

2 keys Widget we will use alot working with Flutter

![[/image 11 7.png|image 11 7.png]]

Column’s (Row’s) arguments is a list of Widgets

  

There are 3 types of buttons: Elevated (Button with bg color and shadow), Text (Button with only pressable text), Outline (Button with no background color but has border)

Button takes 2 argument: onPressed and child

```Dart
ElevatedButton(onPressed: onPressed, child: child)
```

- child: if we want a Widget wrapped inside the button (typically a Text() Widget)
- onPressed: requires a function or no. We have 2 options:
    - Define the function right there by using () {} (anonymous function)
        
        ```Dart
        ElevatedButton(
        	onPressed: () {
        		//code...
        	},
        	child: const Text('Roll the dice'),
        )
        ```
        
    - Define a method somewhere and pass to it (methods have to be void, because onPressed wants a function that returns nothing)
        
        ```Dart
        void rollDice(){
        	//code
        }
        
        ElevatedButton(
        	onPressed: rollDice,    //no () 
        	child: const Text('Roll the dice'),
        )
        ```
        

![[/image 12 7.png|image 12 7.png]]

  

![[/image 13 6.png|image 13 6.png]]

As we can see, even though the Column() Widget is wrapped inside Center() Widget, it still on the top of the screen. This is because Columns simply ==**take the entire available space vertically**== → No way of centering it vertically

```Dart
child: Center(
        child: Column(
          children: [
            Image.asset(
              'assets/images/dice-images/dice-1.png',
              width: 300,
            ),
            ElevatedButton(
              onPressed: () {},
              child: const Text('Roll the dice'),
            )
          ],
        ),
      ),
```

⇒ We must make sure that Column ==**does not take the entire vertical space**== by setting the ==**mainAxisSize**== (**main** axis of the **column** is **vertical** axis)

By default, it is max, which takes all the available space, so we set it to min

```Dart
child: Column(
	mainAxisSize: MainAxisSize.min,
	children: [
	...
```

  

![[/image 14 4.png|image 14 4.png]]

To style the button, we add the style attribute to the TextButton and create a TextButton object with the styleFrom() constructor

Padding is some spacing inside of the widget, between the widget content and the widget boundaries, and it wants edgeInsetGeometry object type. Here we use EdgeInsets.==**all**==(value), which add a certain amount of padding into ==**all**== directions, or EdgeInsets.==**only**==(…) to just add padding to some certain sides.

Option 2: Add a SizedBox Widget between the button and the dice to replace padding

SizedBox has fixed width and height (set by user), which will cut off text or content if it exceeds

  

  

# Stateful Widgets

Now we want our dice image to change randomly when we roll the dice. Right of the bat, we think we might change the image path whenever we click the button and the function `rollDice` inflicts.

![[/image 15 3.png|image 15 3.png]]

We also want to change the Widget to not handle ==**const,**== because this Widget will be changed while using.

→ It won’t work, the image didn’t change, but it still print out “Changing image” due to the fact that we are using a ==**Stateless Widget**==, which is meant to building a non-changing Widget.

  

For Widgets that have internally changing data, we use ==**Stateful Widget**==

Stateful Widget allows us to manage state inside of them.

State: data that may change over time, and that should impact the rendered UI

  

But since the Widget only change at the dice image, it would be overkill to define the whole Widget as Stateful, so we will still make the Widget as Stateless, but the dice part will be Stateful Widget, which contains the image and the button.

  

```Dart
import 'package:flutter/material.dart';

class DiceRoller extends StatefulWidget {
  const DiceRoller({super.key});

  @override
  State<DiceRoller> createState() => _DiceRollerState();
}

class _DiceRollerState extends State<DiceRoller> {
  var activeDiceImage = 'assets/images/dice-images/dice-1.png';
  void rollDice() {
    activeDiceImage = 'assets/images/dice-images/dice-4.png';
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Image.asset(
          'assets/images/dice-images/dice-1.png',
          width: 300,
        ),
        TextButton(
          onPressed: rollDice,
          style: TextButton.styleFrom(
            padding: const EdgeInsets.all(10),
            foregroundColor: Colors.white,
            textStyle: const TextStyle(
              fontSize: 40,
            ),
          ),
          child: const Text(
            'Roll the dice',
          ),
        )
      ],
    );
  }
}
```

createState() does not take value but instead returns a value which is a State object.

State is a generic value type, and we inform Dart which kind of State will be managed here (state for DiceRoller class or Widget).

We have to return the value State<DiceRoller> type in the createState(), and that value is created in an another class: _DiceRollerState, and that class has to extend State<DiceRoller>.

→ When we work with StatefulWidget, we will always work with two classes.

Underscore (_) is the convention of Dart to say that this class is private, only usable in this file.

We can add `const` to the constructor of Stateful Widget, even though Stateful Widget is able to change internally thanks to the class separation. In the end, Flutter make sure that the State object can change, which is why we don’t add a `const` constructor to that, but the Widget will be kept constant by Flutter..

→ Even though we use Stateful Widget, State<> and all the stuff, it still doesn’t work.

⇒ This is because Flutter (or other programming languages) ignore and won’t re-execute the build() method whenever our variable (activeDiceImage) changes. And to update the UI, it must re-execute the build() method.

⇒ We must find some way to get Flutter to re-execute the build() method of this Widget (or this Widget’s state)

  

We call a special function where we updated a value that is used inside of build() method and that will lead to different UI output: ==**setState()**==

```Dart
var activeDiceImage = 'assets/images/dice-images/dice-1.png';

void rollDice() {
  setState(() {
    activeDiceImage = 'assets/images/dice-images/dice-4.png';
  });
 }
```

Since we extended State<> class, we have this function called setState().

To setState(), we must pass in a function, typically we pass an ==**anonymous function**== () {}

Inside the anonymouse func, we should now perform any updates to class, object variables that should be reflected in the UI.

→ setState() in the end tells Flutter that it should re-execite the build() method of this ‘state’ (which we call setState), and update all the places where updates are needed (here it will change the image in the UI).

  

Using Random

```Dart
var activeDiceImage = 'assets/images/dice-images/dice-1.png';
  void rollDice() {
    var diceRolled = Random().nextInt(6) + 1;
    setState(() {
      activeDiceImage = 'assets/images/dice-images/dice-$diceRolled.png';
    });
  }
```

Random().nextInt(6) will generate randomly from 0 to 5, so we add 1 to make it 1 to 6

Dart support string interpolation by using $variableName inside a string

But the Random() object will be created everytime we roll the dice, so we will declare it as final, which will be created once in the whole app life cycle

```Dart
class _DiceRollerState extends State<DiceRoller> {
  var activeDiceImage = 'assets/images/dice-images/dice-1.png';
  final randomizer = Random();
  void rollDice() {
    var diceRolled = Random().nextInt(6) + 1;
    setState(() {
      activeDiceImage = 'assets/images/dice-images/dice-$diceRolled.png';
    });
  }
```

We can even put it outside 2 classes

```Dart
import 'dart:math';

import 'package:flutter/material.dart';

final randomizer = Random();

class DiceRoller extends StatefulWidget {
  const DiceRoller({super.key});

...
```

# Icons

Flutter provides us lots of pre-defined icons by using Icons class

If we want to create a button that contains both icon and text, we can use the icon() constructor of the button

```Dart
ElevatedButton.icon(
            onPressed: () {},
            style: const ButtonStyle(
              backgroundColor:
                  MaterialStatePropertyAll(Color.fromARGB(177, 145, 219, 27)),
            ),
            icon: const Icon(Icons.arrow_circle_right_outlined),
            label: const Text('Start Quiz'),
            )
```

instead of child:, it turns into ==**label**==:

# Opacity

To set opacity for a widget, there are 2 options:

### Use the Opacity widget

By using the Opacity Widget, it provides us the named argument `opacity`

![[/image 16 3.png|image 16 3.png]]

But we should avoid this way because it’s performance intensive

  

### Use the color named argument

![[/image 17 3.png|image 17 3.png]]

Instead, we could add a color layer, which has the opacity attribute and set it from 0 to 255

  

⇒ The Opacity Widget keeps the original color, while the color named argument performance is better, it requires you to choose a color. If the image has multiple color and we want to keep the original color, we might want to use Opacity widget instead of color named argument.

# Rendering Content Conditionally and Lifting State Up

First, let’s create 2 Widget called Quiz and QuizPage

quiz.dart

```Dart
import 'package:flutter/material.dart';
import 'package:quiz_app/pages/home_page.dart';

class Quiz extends StatefulWidget {
  const Quiz({super.key});

  @override
  State<Quiz> createState() {
    return _QuizPageState();
  }
}

class _QuizPageState extends State<Quiz> {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: const HomePage(),
        ),
      ),
    );
  }
}
```

  

quiz_page.dart

```Dart
import 'package:flutter/material.dart';

class QuizPage extends StatefulWidget {
  const QuizPage({super.key});

  @override
  State<QuizPage> createState() => _QuizPageState();
}

class _QuizPageState extends State<QuizPage> {
  @override
  Widget build(BuildContext context) {
    return const Text('Quiz Screen');
  }
}
```

  

main.dart

```Dart
import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';
import 'package:quiz_app/pages/quiz/quiz.dart';

void main() {
  runApp(const Quiz());
}
```

We put the MaterialApp from main to the quiz.dart widget

  

To switch screen from HomePage to QuizPage when click the ‘Start Quiz’ button, we need to get to know 2 new concepts

- Render Content Conditionally
- Lifting State Up

### **Render Content Conditionally**

If we want to replace some content on the screen with other content (for example, after a button has been pressed) we have to replace the widget in our code. Here is ==**HomePage**==()

```Dart
import 'package:flutter/material.dart';
import 'package:quiz_app/pages/home_page.dart';

class Quiz extends StatefulWidget {
  const Quiz({super.key});

  @override
  State<Quiz> createState() {
    return _QuizPageState();
  }
}

class _QuizPageState extends State<Quiz> {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: const HomePage(),
        ),
      ),
    );
  }
}
```

What we could do is create a variable called ==**activeScreen**== and set it equal to HomePage() and add a method called **switchScreen** where we want to navigate to different screen

```Dart
class _QuizPageState extends State<Quiz> {
  Widget activeScreen = const HomePage();

  void switchScreen() {
    setState(() {
      activeScreen = const QuizPage();
    });
  }
 ....
```

Now we can use the ==**activeScreen**== variable as a value for child: → we can output different Widget and rebuild because we called setState() whenever switchScreen() is executed. But the switchScreen() is never executing because it doesnt connect to any button. ⇒ ==**Lifting State Up**==

  

### Lifting State Up

### Problem

![[/image 18 3.png|image 18 3.png]]

  

### Solution

![[/image 19 3.png|image 19 3.png]]

Quiz here is more like App

  

```Dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:quiz_app/pages/home_page.dart';
import 'package:quiz_app/pages/quiz/quiz_page.dart';

class Quiz extends StatefulWidget {
  const Quiz({super.key});

  @override
  State<Quiz> createState() {
    return _QuizPageState();
  }
}

class _QuizPageState extends State<Quiz> {
  Widget activeScreen = const HomePage();

  void switchScreen() {
    setState(() {
      activeScreen = const QuizPage();
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: activeScreen,
        ),
      ),
    );
  }
}
```

The code above already manage and update state (switchScreen(), activeScreen), and we are rendering content conditionally (child: activeScreen) → We basically lifted the state up, but we haven’t connected the switchScreen() func to the screen contains the button (HomePage) that should trigger the func.

→ It’s not enough to just manage the state in some shared parent Widget (Quiz), we also must ensure that the child Widgets (HomePage, QuizPage) should initiate the state change. In this case, ==**HomePage needs to have access to the state changing function (switchScreen()) defined in the parent Widget**==. ⇒ ==**Passing Functions as Values**==

We pass a pointer at switchScreen() to HomePage()

```Dart
Widget activeScreen = const HomePage(switchScreen);

void switchScreen(){...}
```

  

```Dart
class HomePage extends StatelessWidget {
  // const HomePage(void Function() startQuiz, {super.key});
  const HomePage(this.startQuiz, {super.key});
  
  final void Function() startQuiz;
```

This pass a pointer of the function to the HomePage() as a value, and in HomePage(), we can call the function.

![[/image 20 3.png|image 20 3.png]]

  

```Dart
ElevatedButton.icon(
            onPressed: startQuiz,
            style: const ButtonStyle(
              backgroundColor:
                  MaterialStatePropertyAll(Color.fromARGB(177, 145, 219, 27)),
            ),
            icon: const Icon(Icons.arrow_circle_right_outlined),
            label: const Text('Start Quiz'),
          ),
```

  

But we still get an error

![[/image 21 3.png|image 21 3.png]]

This error is related to having const before HomePage(), but even when we remove const, there is still error. The error is because we are using switchScreen here when initializing the activeScreen variable. This basically happens at same point of time, where switchScreen() is created → It happens to early. Both activeScreen and switchScreen initialization happens when _QuizPageState class is turned into an object → It’s not guaranteed that switchScreen is existed yet → ==**Using initState() method**==

initState() is a method (provided by State<>class) we typically want to add to our State classes to do some extra initialization work when that State object is created for the first time. initState() will be executed once after the object has been created (never execute again) → We can use all the variables in here

```Dart
class _QuizPageState extends State<Quiz> {
  Widget? activeScreen;

  @override
  void initState() {
    activeScreen = HomePage(switchScreen);
    super.initState();
  }

  void switchScreen() {
    setState(() {
      activeScreen = const QuizPage();
    });
  }
```

![[/image 22 3.png|image 22 3.png]]

  

  

# No initState() option

We could use ternary expression at child: to yield the corresponding screen, therefore we could you conditions (if-else) to show different screens, not just ternary. It does not require initState()

  

```Dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:quiz_app/pages/home_page.dart';
import 'package:quiz_app/pages/quiz/quiz_page.dart';

class Quiz extends StatefulWidget {
  const Quiz({super.key});

  @override
  State<Quiz> createState() {
    return _QuizPageState();
  }
}

class _QuizPageState extends State<Quiz> {
  var activeScreen = 'home-page';

  // @override
  // void initState() {
  //   activeScreen = HomePage(switchScreen);
  //   super.initState();
  // }

  void switchScreen() {
    setState(() {
      activeScreen = 'quiz-page';
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: activeScreen == 'start-screen'
              ? HomePage(switchScreen)
              : const QuizPage(),
        ),
      ),
    );
  }
}
```

Note that we still have to pass switchScreen to HomePage because HomePage still need that function for its button

  

Another alternatives

```Dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:quiz_app/pages/home_page.dart';
import 'package:quiz_app/pages/quiz/quiz_page.dart';

class Quiz extends StatefulWidget {
  const Quiz({super.key});

  @override
  State<Quiz> createState() {
    return _QuizPageState();
  }
}

class _QuizPageState extends State<Quiz> {
  var activeScreen = 'home-page';

  // @override
  // void initState() {
  //   activeScreen = HomePage(switchScreen);
  //   super.initState();
  // }

  void switchScreen() {
    setState(() {
      activeScreen = 'quiz-page';
    });
  }

  @override
  Widget build(BuildContext context) {
    Widget screenWidget = HomePage(switchScreen);

    if (activeScreen == 'quiz-page') {
      screenWidget = const QuizPage();
    }

    return MaterialApp(
      home: Scaffold(
        body: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: screenWidget,
        ),
      ),
    );
  }
}
```

Read more about if and lists: [https://github.com/dart-lang/language/blob/main/accepted/2.3/control-flow-collections/feature-specification.md](https://github.com/dart-lang/language/blob/main/accepted/2.3/control-flow-collections/feature-specification.md)

# Configuring a Column

First, we create QuestionQuiz class with some dummy data

```Dart
class QuizQuestion {
  const QuizQuestion(this.text, this.awnsers);

  final String text;
  final List<String> awnsers;
}
```

```Dart
import 'package:quiz_app/models/quiz_question.dart';

const questions = [
  QuizQuestion(
    'What are the main building blocks of Flutter UIs?',
    [
      'Widgets',
      'Components',
      'Blocks',
      'Functions',
    ],
  ),
  QuizQuestion('How are Flutter UIs built?', [
    'By combining widgets in code',
    'By combining widgets in a visual editor',
    'By defining widgets in config files',
    'By using XCode for iOS and Android Studio for Android',
  ]),
  ...
];
```

We want to output all the Questions and Options below the questions in the QuizPage

```Dart
class _QuizPageState extends State<QuizPage> {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        children: [
          const Text('question'),
          const SizedBox(
            height: 30,
          ),
          ElevatedButton(onPressed: () {}, child: const Text('Awnser 1')),
          ...
        ],
      ),
    );
  }
}
```

We could use Center Widget to center the Quiz, but another option would be wrapping it with a ==**SizedBox**== Widget

```Dart
class _QuizPageState extends State<QuizPage> {
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text('question'),
          const SizedBox(
            height: 30,
          ),
          ElevatedButton(onPressed: () {}, child: const Text('Awnser 1'))
        ],
      ),
    );
  }
}
```

By setting width to double.infinity (a special value built into Dart), it will takes as much width as possible (suitable for each phone)

mainAxisAlignment: MainAxisAlignment.center: set the main axis of column (vertical) to center

![[/image 23 3.png|image 23 3.png]]

```Dart
import 'package:flutter/material.dart';

class AnwserButton extends StatelessWidget {
  const AnwserButton(this.anwserText, this.onPressed, {super.key});

  final String anwserText;
  final void Function() onPressed;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
          backgroundColor: const Color.fromARGB(255, 8, 148, 235),
          foregroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(40))),
      child: Text(anwserText),
    );
  }
}
```