# Database Design Process

We ask ourselves 3 questions:

![[image.png]]

  

Example:

![[image 1.png]]

  

  

  

# Creating Tables

Convention:

- ==Keyword== (VARCHAR, CREATE,…) will always be ==**capitalized**==
    - ==Identifer== (name, country,…) will always be ==**lowercase**==

```SQL
CREATE TABLE <name> (
	...
);
```

Ex:

```SQL
CREATE TABLE cities(
	name VARCHAR(50),
	country VARCHAR(50),
	population INTEGER,
	area INTEGER
);
```

# Inserting Data

Convention:

- We should add ; at the end of the statement

```SQL
INSERT INTO <tbl-name> (list_of_columns) 
VALUES (values);
```

Example:

```SQL
INSERT INTO cities (name, country, population, area)
VALUES ('Tokyo', 'Japan', 3850000, 8223);
```

  

We can skip[ the list_of_columns and jump straight into values, but the values need to be in order with the columns

![[image 2.png]]

By using list_of_columns, we can change the position (order) of the values

  

## Inserting multiple rows

```SQL
INSERT INTO <tbl-name> (list_of_columns) 
VALUES 
	(values),
	(values),
	(values);
```

Example:

```SQL
INSERT INTO cities (name, country, population, area)
VALUES 
	('Tokyo', 'Japan', 3850000, 8223),
	('Shanghai', 'China', 2200000, 4015),
	('Sao Paulo', 'Brazil', 2090000, 3043);
```

# Retrieving Data

```SQL
SELECT * FROM <tbl-name>
```

```SQL
SELECT column1, column2, column3 FROM <tbl-name>
```

We can print out 1 column multiple times

```SQL
SELECT column1, column1, column1 FROM <tbl-name>
```

# Calculated Columns

For example: we want to get the **Density** of ==**all cities**== (population / area) → We can do some calculation

```SQL
SELECT name, population / area FROM cities
```

![[image 3.png]]

There are many operators we can use:

![[image 4.png]]

  

Notice we get the result column name as ==**?column?**== because Postgres doesn’t know what to call it.

To rename it, we will use ==**AS**== keyword

```SQL
SELECT name, population / area AS density
FROM cities
```

# String Operators and Functions

![[image 5.png]]

|| is called **pipe** operator

Example:

pipe:

![[image 6.png]]

  

CONCAT():

![[image 7.png]]

  

LOWER(), UPPER():

![[image 8.png]]

![[image 9.png]]

  

LENGTH():

![[image 10.png]]

  

# Filter Rows

```SQL
SELECT name, area 
FROM cities
WHERE area > 4000;
```

Steps order:

- First: FROM cities
- Second: WHERE area > 4000
- Third: SELECT name, area

![[image 11.png]]

Examples:

```SQL
SELECT *
FROM cities
WHERE area BETWEEN 2000 AND 4000;
```

  

```SQL
SELECT *
FROM cities c
WHERE c.name IN ('Tokyo', 'Shanghai');
```

  

### Compound WHERE

We can combine multiple conditions in one WHERE statement

```SQL
SELECT *
FROM cities c
WHERE c.name IN ('Tokyo', 'Shanghai') AND AREA < 4000;
```

  

### Calculations in WHERE

We can do calculations in WHERE statement

```SQL
SELECT name, population / area AS density
FROM cities c
WHERE population / area > 6000;
```

# Updating / Deleting Records

### Updating

```SQL
UPDATE <tbl-name>
SET <property-name>
WHERE <conditions>
```

Example:

```SQL
UPDATE cities
SET population = 39000000;
WHERE name = 'Tokyo';
```

  

### Deleting

```SQL
DELETE FROM <tbl-name>
WHERE <conditions>
```

Example:

```SQL
DELETE FROM cities
WHERE name = 'Tokyo'
```

# Auto-Generated IDs

We can mark the Primary Key as auto-generated by using ==**SERIAL**== keyword (1, 2, 3, 4,…)

```SQL
CREATE TABLE users(
	id SERIAL PRIMARY KEY,
	username varchar(50)
);
```

# Creating Foreign Key Columns

```SQL
CREATE TABLE photos (
	id SERIAL PRIMARY KEY,
	url varchar(200),
	<col-name> <data-type> REFERENCES <tbl-name>(col-name)
);
```

Example:

```SQL
CREATE TABLE photos (
	id SERIAL PRIMARY KEY,
	url varchar(200),
	user_id INTEGER REFERENCES users(id)
);
```

# Foreign Key Constraints Around Insertion

Another term is ==**Data Consistency**==. This term refers to the ability of our Database to make sure that the information we are inserting into it and working with make senses.

![[image 12.png]]

  

  

# Constraints Around Deletion

> What happens when we try to delete a Record that involves a FK?

Example:

We have a bunch of photo records which contains user_id of 1. What happens if we delete user with the id of 1?

→ We will have some dangling keys, dangling references, which will point to a non-exists user, and never will be existed (because SERIAL doesn’t reuse ID)

  

We have a couple options we can use:

![[image 13.png]]

By default, if we don’t specify anything is ==**ON DELETE RESTRICT**==

- Difference between **RESTRICT** and **NO ACTION**:
    
      
    

  

```SQL
CREATE TABLE photos (
	id SERIAL PRIMARY KEY,
	url varchar(200),
	user_id INTEGER REFERENCES users(id) <options>
);
```

```SQL
CREATE TABLE photos (
	id SERIAL PRIMARY KEY,
	url varchar(200),
	user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
);
```

```SQL
CREATE TABLE photos (
	id SERIAL PRIMARY KEY,
	url varchar(200),
	user_id INTEGER REFERENCES users(id) ON DELETE SET NULL
);
```

  

# Joins and Aggregation

![[image 14.png]]

## Join

Example of Join:

![[image 15.png]]

  

What Join does: It connects 2 tables with the common data (userId) we specified

![[image 16.png]]

  

### Notes on Join

![[image 17.png]]

- Different ordering of FROM and JOIN can makes a difference:
    
    ![[image 18.png]]
    
- If names collide (same name), postgres doesn’t know which column to use

```SQL
SELECT user_id
FROM ...

-> ambiguous
```

![[image 19.png]]

  

- renaming tables:

```SQL
SELECT * 
FROM photos AS p
...

--or 
SELECT * 
FROM photos p
...
```

  

### Different kinds of Joins

![[image 20.png]]

By default, when we use JOIN, it’s INNER JOIN

If there’s a row that doesn’t match up with the other table, it gets dropped

  

![[image 21.png]]

  

  

![[image 22.png]]

  

  

![[image 23.png]]

### Joining multiple tables

We can join more than 2 tables

Example:

```SQL
select p.url, c.contents, u.username 
from "comments" c 
join photos p on c.photo_id = p.id 
join users u on u.id = p.user_id
where c.user_id = p.user_id 
```

## Grouping & Aggregation

![[image 24.png]]

  

### Understanding how GROUP BY works

![[image 25.png]]

Whenever we use GROUP BY, our database will take a look at all the rows we have selected at this point. It will go through all the different rows, it’s gonna find the user_id column, and it tries to find all the unique values inside that column.

Important: We can only select the GROUPED Columns (Columns appear in GROUP BY) or Columns used in an aggregate function

  

  

### Aggregate Functions

Some Aggregate Functions:

![[image 26.png]]

### Combining GROUP BY & Aggregate functions

![[image 27.png]]

Aggregate functions will do operation and calculation on each group separately

Example: longest comment of each user

![[image 28.png]]

  

==**Count() does not count NULL**==:

Here, photos table have 21 values, but the user_id of the 21st photo is NULL

![[image 29.png]]

If we count [photos.id](http://photos.id) it will be 21, because the 21st photo’s id is not null

![[image 30.png]]

But if we count by user_id, it will be 20, since the 21st user_id is NULL

![[image 31.png]]

  

We can count number of rows by using *

```SQL
SELECT COUNT(*) FROM photos;
```

This will count total number of rows

  

  

### Filtering Groups with Having

Order of query

![[image 32.png]]

HAVING ==**must**== have GROUP BY

GROUP BY ==**doesn’t**== need to have HAVING

HAVING is like ==**WHERE**== but for ==**Groups**==

  

Example:

![[image 33.png]]

```SQL
select c.photo_id, count(*)
from "comments" c 
where c.photo_id < 3
group by c.photo_id 
having count(*) > 2;
```

  

![[image 34.png]]

```SQL
select c.user_id, count(*)
from "comments" c 
where c.photo_id <= 50
group by c.user_id 
having count(*) > 20;
```

# Offset and Limit

==**OFFSET**== keyword ==**skip**== the first x rows of the result sets

```SQL
SELECT * 
FROM orders
OFFSET 30;
```

  

==**LIMIT**== keyword ==**takes**== the first x rows of the result set

```SQL
SELECT * LIMIT 20
FROM orders

--or

SELECT * 
FROM orders
LIMIT 20
```

If both ==**OFFSET**== and ==**LIMIT**== appears in the query, it will always ==**skip first then take**==

Example:

```SQL
SELECT * 
FROM product 
ORDER BY price DESC
LIMIT 5
OFFSET 1;
```

This means take the 5 most expensive products except the most expensive

By convention, we put ==**LIMIT**== before ==**OFFSET**== (we can still put OFFSET before LIMIT)

### Applications

- Use LIMIT to find top/most/worst/…
- USE both LIMIT and OFFSET for ==**pagination**==

# Sorting Records

To sort record, we use ==**ORDER BY**== keyword

```SQL
select *
from products p 
order by p.price desc;
```

By default, it’s ==**ASC**==, which stands for ascending (tăng dần)

We can reverse it using ==**DESC**==, which stands for descending (giảm dần)

  

We can also sort by characters (alphabetical)

```SQL
select *
from products p 
order by p.name;
```

  

We can have multiple sorting rules:

```SQL
select *
from products p 
order by p.price, p.weight DESC;
```

This means if there are rows with same price, it will then these rows by weight ==**descendingly**== (since we marked it as desc)

→ price is first sorting criteria, weight is second sorting criteria

# Unions & Intersections with Sets (results of queries)

![[image 35.png]]

## Union

### Problem

![[image 36.png]]

price/weight: means that it’s the most efficient ratio (high price/low weight). Assuming that weight causes shipping price to raise. → most profit

Let’s write out single query for the problem above:

```SQL
select p.id, p."name" , p.price 
from products p 
order by p.price desc
limit 4
```

```SQL
select p.id, p."name" , p.price 
from products p 
order by p.price / p.weight desc
limit 4
```

We can kind of “Join” the result set of these 2 queries using ==**UNION**== keyword

```SQL
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price desc
	limit 4
)
UNION 
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price / p.weight desc
	limit 4
);
```

![[image 37.png]]

This is the result set with 4 highest price items and 4 most profitable items. But notice that we only have 7 items on the list instead of 8. The reason for that is that one of these different products is present in both sub-result list, so ==**UNION**== only list that row 1 single time.

If we don’t want ==**UNION**== to remove that duplicate, we can add ==**ALL**== to the ==**UNION**==

```SQL
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price desc
	limit 4
)
UNION ALL
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price / p.weight desc
	limit 4
);
```

![[image 38.png]]

### Notes on Union

- We should put parentheses ‘()’ on each queries to avoid confusion for the database if the queries consist many statements
- We ==**can only**== use UNION keyword between 2 results set with the ==**same columns**== and ==**same data types**==

  

## Intersection

```SQL
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price desc
	limit 4
)
INTERSECT 
(
	select p.id, p."name" , p.price 
	from products p 
	order by p.price / p.weight desc
	limit 4
);
```

==**INTERSECT**== will show us the common row of 2 result sets

![[image 39.png]]

→ This product is the both in top 4 highest price products and top 4 most profitable products

  

Similarly to UNION ALL, INTERSECT ALL doesn’t remove duplicates

![[image 40.png]]

Here, we still have one because in both result sets, product with id 7 only appears once in both sets. If one of the sets appears to have product 7 more than one, it will show here.

## Except

As the name implies, ==**EXCEPT**== keyword will only show the items of the first query that don’t appear in the second query’s result set.

Unlike the previous keywords, orders does matter when using ==**EXCEPT**==

![[image 41.png]]

# Subqueries

## Problem

![[image 42.png]]

To combine these 2 queries, we first have to write out the ==**outer query**== (second query) first

```SQL
select p."name", p.price 
from products p 
where p.price > 
```

after the ‘>’, we would want to have the first query’s result

```SQL
select p."name", p.price 
from products p 
where p.price > (
	select max(p.price)
	from products p
	where department = 'Toys'
	);
```

By putting a set of parentheses ‘()’, it creates a sub-query. In here, we can write a second query. Sub-query will be executed first be the Database, then the result of it will be taken and provide it to the outer query.

We don’t put semicolon ‘;’ at the end of the sub-query

We can use sub-queries in ==**many different locations**==

Example:

![[image 43.png]]

(This query is just for showcase, it doesn’t have meaning)

There are 4 separated sub-queries inside here:

- SELECT
- FROM
- JOIN
- WHERE

![[image 44.png]]

Different subqueries can generate different ==**shape of data**==

- SELECT: the subq here is producing a single value
- FROM, JOIN: the subq here are producing a source of rows
- WHERE: the subq here is producing a single column

![[image 45.png]]

## Subqueries in SELECT

- First scenario: Putting subq in a SELECT statement
    
    - If we want to add subq to a SELECT statement, we must add in a subq that results in a ==**single value**==
    - It is useful when we want to calculate one single value that is result of several other values
    - By using subquery, we can ==**use SELECT without a FROM,**== as long as the query returns a single value (not a column or columns and rows)
        
        Example:
        
        We want to find the ratio
        
    
    ![[image 46.png]]
    
    Example: (Might not meaningful, just for showcase)
    
    ![[image 47.png]]
    
    ![[image 48.png]]
    

  

## Subqueries in FROM

Subqueries inside FROM is quite flexbile

We can return a ==**wide variety of different structures of data**== in FROM clause

![[image 49.png]]

It’s all about making sure that the outer query is compatible with the subquery

Whenever we make use of a subquery inside of the FROM clause, we ==**must apply an alias to the result of the subquery**== (AS p)

Behind the scenes:

![[image 50.png]]

If we SELECT price or weight in the outer query, we will get the error, since there is no price or weight column in the subquery

Example:

![[image 51.png]]

  

Visualize solution

![[image 52.png]]

```SQL
	select avg(user_order.user_orders_number)
from (
	select o.user_id, count(*) as user_orders_number
	from orders o 
	group by o.user_id
) as user_order
```

## Subqueries in JOIN

![[image 53.png]]

  

Behind the scenes:

![[image 54.png]]

First it will find the orders that product_id = 3. The outer query join with the result set ON user_id. At the beginning, the outer query has 5 rows, id 1 → 5. But since this is INNER JOIN and the subquery only found 1 row for the outer query, it dumps all the rows from 1 → 4, left behind 5.

(This query is not really useful, just for showcase the query)

## Subqueries in WHERE (Very useful)

We usually use subqueries in WHERE clause

![[image 55.png]]

The valid subquery will depends on the operator we use in the WHERE clause

Some operators:

![[image 56.png]]

The ==**ALL**== keyword make sure that the left value is >,< ,≥,… than ==**all**== the values on the right

==**SOME**== is the alias for ==**ANY**== → We can interchange these 2 keywords, they do the exact same thing. It evaluates the value on the left hand side if it’s >,<,≥,… than at least 1 value on the right hand side.

Example for SOME:

![[image 57.png]]

![[image 58.png]]

This will take all the product with the price larger than at least one product in the Industrial department

## Correlated Subqueries

A ==**correlated subquery**== is a ==**subquery that depends on the outer query for its values**==. Unlike a simple subquery, which is evaluated only once, a correlated subquery is ==**evaluated for each row processed by the outer query**==.

→ It works like a ==**double nested for loop**==

⇒ Suitable for comparing each item with another item repeatedly.

  
In a correlated subquery:  

- The subquery refers to columns in the outer query, creating a dependency.
- The subquery runs ==**repeatedly**==, once for each row selected by the outer query.

  

## Example

**Dataset**

![[image 59.png]]

The first statement which will run is ==**FROM**==. It will fetch ==**each row**== from the ‘products’ table and give it to ==**WHERE**==. In WHERE, we have a subquery, which ==**reference to the outer query**== (p1.department).

This works as follow: the subquery will ==**go through all the rows**== in the ‘products’ table, but it will only select rows ==**WHERE department = department**== of the ==**current chosen row of the outer query**==. Then it will SELECT the max price of all the chosen rows. After that, we will get the ==**first WHERE clause which is p1.price = 876**==. After that, the outer query WHERE clause will ==**continue to run all the rows**==, results in a set of products with highest price in each department

  

![[image 60.png]]

```SQL
select p1."name" , p1.department , p1.price 
from products p1 
where p1.price = (
	select max(p2.price)
	from products p2
	where p2.department = p1.department 
);
```

  

## Example 2

![[image 61.png]]

```SQL
select p1."name", (
	select Count(*)
	from orders o
	where o.product_id = p1.id
)
from products p1
```

# Distinct

- ==**DISTINCT**== will always be placed right after the ==**SELECT**== keyword.
- It will give us a list of all different ==**unique values**== inside of a column (removing duplicates)
- One of the good uses of ==**DISTINCT**== is to print out the number of unique values we have
    
    ```SQL
    SELECT COUNT(DISTINCT department)
    FROM products;
    
    ---
    SELECT DISTINCT department, name --this will give out more values than just deparment
    FROM products;
    
    --If we use 2 or more columns, we can't use COUNT() on it
    SELECT DISTINCT COUNT(department, name) --error
    ```
    

We can use ==**GROUP BY**== in place of ==**DISTINCT**==, but not vice versa

  

# Utility Operators, Keywords, and Functions

## Greatest Value in a list

We can return the largest value in a list by using ==**GREATEST**== keyword

```SQL
SELECT GREATEST(20, 10, 30);
-- 30
```

## Example

![[image 62.png]]

Shipping is either 30 or greater

```SQL
select id, "name", department , price , weight , greatest (weight * 2, 30)
from products p  
```

## Least Value in a list

We can also select the least value in a list using ==**LEAST**== keyword

```SQL
SELECT LEAST(20, 10, 30);
-- 10
```

## Case keyword

## Example

![[image 63.png]]

```SQL
select 
	"name" ,
	price ,
	case 
		when price > 600 then 'high'
		when price > 300 then 'medium'
		else 'cheap'
	end 
from products p ;
```

We can place ==**any kind of comparisions**== that we would normally put in a ==**WHERE**==

It is not required to have ==**ELSE**==, but if there’s a row which does not satisfy the conditions, the value will be ==**null**==. So usually, we want an ELSE

We don’t use usually use ==**CASE,**== since we would do this kind of comparisions at server, code level

  

# Postgresql

## Data type categories

Some data type categories of Postgres:

![[image 64.png]]

  

### Numeric types

![[image 65.png]]

  

![[image 66.png]]

We can convert number type by using 2 colons ::

![[image 67.png]]

### Charater types

![[image 68.png]]

CHAR(x) will always be the length of x, if the length is not enough, it will add spaces (’ ‘)

### Boolean types

![[image 69.png]]

We can put string ‘yes’, ‘on’,… and Postgres will convert it to boolean

### Times, dates, and timestamps

### Date

![[image 70.png]]

Postgres is very flexible because we can enter any format of dates in string and it will convert for ujs

  

### Time

We can store Time with or without a Time zone

![[image 71.png]]

  

![[image 72.png]]

![[image 73.png]]

![[image 74.png]]

z stands for zero

  

### Timestamp with Time Zone

![[image 75.png]]

![[image 76.png]]

  

### Interval

![[image 77.png]]

![[image 78.png]]

  

We can also do ==**add or subtraction**== interval and also time (all above)

![[image 79.png]]

# Database-side validations and Constraints

![[image 80.png]]

The last line of Database is actually a good thing, to avoid edge cases or exceptions. If we only have Web Server validations, Database can still store invalid data

→ It’s best to use both Web Server and Database validation

⇒ We can mostly validate on Web Server level, and put some really ==**critical validations**== on Database level

## Row-Level Validation

![[image 81.png]]

  

### Applying Null Constraints

There are 2 ways:

Set column as NOT NULL when we ==**first create**== the table

```SQL
CREATE TABLE products(
	...
	price INTEGER NOT NULL,
	...
);
```

  

After the ==**table was created**==

```SQL
ALTER TABLE products
ALTER COLUMN price
SET NOT NULL
```

There is a little note:

If our price column ==**already has some null data**==, the statement above won’t work

There are 2 options for this:

- We can find all the rows with the price of null and delete them, then we can apply the rule
- Write a query to find and update all the null values to another values

```SQL
UPDATE products
SET price = 99999
WHERE price IS NULL;
```

⇒

![[image 82.png]]

### Default Column Values

There are 2 ways:

![[image 83.png]]

### Applying Unique Constraints to one Column

By applying this rule, we can’t have 2 rows with the same value of something we set.

![[image 84.png]]

Note: Like null constraints, we can only set the Unique constraints when the values are already unique.

Options:

- We can temporarily rename the value
- Write query to delete all duplicated names

  

### Removing Constraints

To remove Constraints, go to the Constraints of the table

![[image 85.png]]

And then write:

```SQL
ALTER TABLE <tbl-name>
DROP CONSTRAINT <constr-name>;
```

### Multi-Column Uniqueness

To create a unique combination of value

![[image 86.png]]

Like this, if we have 2 products with (Shirt, Household), (Shirt, Clothes), it will still added to Database, but if 2 products both have the same name and department, it will violate the constraint

### Validation check

When we add rows, we can check if it’s >,<,≥,… with some other value

![[image 87.png]]

Like every other validations, we can’t apply the rule if there are some rows already don’t satisfy the constraint

==**A check can only work on the row we are adding/updating**==

→ We can’t do subquery on the CHECK, we are ony allowed to work with the Column inside the row we are trying to add/update

  

### Check over multiple Columns

For example: like if we want to check created_date must be before update_dated,

or an order created_date must be before the shipped_date

![[image 88.png]]

Or

![[image 89.png]]

# Polymorphic Association

For example:

We have a Likes table, which contains user_id and the target that the user liked, it could be a post or a comment. But we can’t put that column as a FK for both comment_id and post_id

First solution would be creating the column called liked_id, which is not a reference to any keys, and add a second column called liked_type, which indicates post or comment. This is not a good approach

The better solution would be creating 2 FK columns, each references to comment_id and post_id. And we want to make sure each row has one of them null (post_id or comment_id)

![[image 90.png]]

We have to add a validation to ensure whenever we insert a row, either post_id or comment_id is defined (not null and exists)

COALESCE takes all the argument it got provided, and it’s gonna return the first value that is not null in the list

Example:

SELECT COALESCE(NULL, NULL, NULL, NULL, 10, NULL, 5)

→ Returns 10

SELECT COALESCE(5, 10)

→ Returns 5

  

COALESCE((post_id)::BOOLEAN:INTEGER, 0)

This means we are converting the post_id to BOOLEAN type. If it’s null then the converted value will be NULL, then it will be convert to INTEGER. Then if it’s null, it will be NULL → COALESCE(NULL, 0) = 0. Else it’s a valid number, the BOOLEAN convertion will be TRUE (1)

Similarly with the second COALESCE

⇒ The CHECK means both of the values add up must be 1, which means ONLY 1 of them must be 1, and the other is 0

  

### Downsides

If there are many different kind of stuff user can likes (video, message,…), there will be lots of columns in the Likes table.

→ Here, the polymorphic association approach is better

![[image 91.png]]

  

### Third approach

On the third approach, we could simply create multiple tables for each type of likes

![[image 92.png]]

  

### Downsides

If we ever want to write a query to aggregate all the different kind of likes, but it still can be done using UNION or a View

# Postgres Performance

This section is about understanding the internal of Postgres itself

## Where does Postgres store data?

We can see the data directory by using

```SQL
SHOW data_directory;
```

SHOW is used for getting configuration option out of our Postgres database

![[image 93.png]]

This is a Linux system’s path because we are using Docker

  

All of the data is stored on a folder called ‘base’

![[image 94.png]]

  

Each of these folder have its own identifer (numbers) and contains all the data of each database on our local machine

![[image 95.png]]

  

We can see the name of the database of each folder like this

![[image 96.png]]

  

In the database folder, these files represent raw data

![[image 97.png]]

  

We can see details abot these files:

![[image 98.png]]

  

This row represents the user table, and its’ identifer is 33251

![[image 99.png]]

And the file with the corresesponding id contains all the data for the user table

⇒ Each file represent a different thing inside the database

## How information is stored inside a file?

![[image 100.png]]

For example: The file 33251 above represents user table and stores all the users is a Heap File

Heap is a data structure, differs from Heap File.

A single Heap File is divided into many Blocks or Pages. In each Block or Page, we have many different Tuples, Items, Rows

![[image 101.png]]

  

By default, each Block(Page) are 8kb inside

![[image 102.png]]

Regardless how many items in each Block, it’s still 8kb

> Why is it 8kb? What’s going on inside of each Blocks?

TODO: Continue section 22

  

# Indexes

Important terms: Pointer

![[image 103.png]]

For example: We have a Heap File with 2 blocks, Block 0 contains user with username Nancy and Alf, Block 1 contains user with username Jia and Riann.

We want to find only the user with username Riann.

An important thing to keep in mind is that when data is inside of a Heap File on our hard drive, Postgres can’t really just examine that file in place → In order to take a look at different users, we have to first load these users up into memory.

Steps of the query:

- Step 1: take a look at all of our different blocks inside of the Heap File
- Step 2: once they are loaded up and are inside of memory, we can start to do further querying or filter on these data

![[image 104.png]]

Whenever we load up information from our hard drive over to memory, it takes a large performance cost → We want to ==**minimize**== the amount of ==**data that is being moved**== between our ==**hard drive**== and the ==**memory**==

Whenever we are loading up a ton of information out of a table and interating those records 1 by 1, we refers to that as a ==**full table scan**==

![[image 105.png]]

This query (select user with username Riann) is a full table scan

  

## Ideas

![[image 106.png]]

We want a tool to tell us exactly where the record we are finding is, instead of loading all the file into memory, it will just go to that Block and just load up that Block, and just get Riann our of there, without fetching any other extra information, such as Block 0

→ Index

Index is a data structure that very efficiently ==**tells us exactly what Block and Index a particular record store at.**==

![[image 107.png]]

  

## How an Index works?

![[image 108.png]]

Whenever we create an Index, we create it on a ==**very specific column**==, that allows us to do a fast look up, whenever we are doing some kind of filtering logic on that same column

→ We would create Index on username column which allows us to run queries that involve username very quickly

![[image 109.png]]

  

After that, it will sort it in some meaningful ways

![[image 110.png]]

  

Then it will put into a tree data structure

![[image 111.png]]

  

Last step, it will add some helpers into the root node

![[image 112.png]]

Inside those root nodes, we are going to put in some ==**directions**==, to decide which leaf node to go down, by listing on each boxes what set of values exists of the corresesponding leaf node, by using inequality

![[image 113.png]]

  

![[image 114.png]]

  

## Creating an Index

```SQL
CREATE INDEX ON <tbl-name> (col-name);

--Create with name

CREATE INDEX <custom-name> ON <tbl-name> (col-name);
```

  

To delete an Index:

```SQL
DROP INDEX <idx-name>;
```

  

We can see the analyze of the query by using 2 keywords:

```SQL
EXPLAIN ANALYZE SELECT *
FROM products
WHERE id = 1
```

![[image 115.png]]

  

![[image 116.png]]

We can see that finding with index is so much faster

0.025ms to 26.115ms

  

==**But index can sometimes not useful and slow our database down**==

## Downsides of Index

![[image 117.png]]

When we create an Index, we were essentially ==**creating some kind of tree data structure**== behind the scenes. In inside that tree data structure, for every row of our actual table, we extracted one piece of information, along with a ==**pointer**== over to some location inside of our Heap File → For ==**every single row, we are now storing, in addition, inside of our index, some piece of information and a pointer**== → That comes with some amount of storage cost. It takes some amount of ==**hard drive space**== just to store this index

Everytime we create an Index, we are using some additional amount of storage space on our computer

We can see the actual size of it:

![[image 118.png]]

users is the table

  

size of the index

![[image 119.png]]

It might look small for a small database, but imagine creating a simple index for a very big database would maybe cost 16gb instead of 16kb. It can save us a lot of money (cloud database) by not stuffing a ton of extra information into our database.

→ Create index = pay money for it. But if we are building a big application and an extra 10$ a month make our application faster then it would be good.

There are other downsides of Index other than just money

![[image 120.png]]

It slows down I/U/D because everytime we make a change to that table, Postgres also has to go and update the Index

Just because an Index exists, doesn’t guarantee that Postgres is going to actually use it

## Index Types

![[image 121.png]]

Everytime we run the `create index` command, we are creating a specific type of index

The common one and the one we want the vast majority of the time is ==**B-Tree**== index

Other type of indexes are really specific cases

  

Posgres does create some indexes for us

![[image 122.png]]

  

# Basic Query Tuning

In this section, we will focus on how to evaluate, what makes a good/bad query. How can we fix, or make it better by creating an Index.

## Query process pipeline

General pipeline

![[image 123.png]]

When we write the query, it will be fed to Postgres, go through the Parser → Rewriter → Planner → Executer

### Parser

It will try to take all the characters of that string (the query) and tear apart 1 by 1 and figure out what the meaning of every character in every word inside there

It ensure what we wrote out is valid SQL

→ It builds up a ==**query tree**== (a programmatic description of the query that we are trying to run)

![[image 124.png]]

  

## Rewriter

The rewriter will take a look at the query tree and possibly make little modifications to it, if Postgres thinks that certain parts could be executed a little bit more efficiently.

What happens much more frequently is it applies the idea of ==**views**== to the query tree itself

![[image 125.png]]

## ==Planner==

This is what we really care about.

The goal of Planner: look at query tree, figure out what information we are trying to fetch → comes up with a series of different plans or strategies that could be use to actually get that information

![[image 126.png]]

  

## Executer

After Planner decides the best strategy to run the query, it hands the query to the Executor and ==**Run**== the query

  

## EXPLAIN & EXPLAIN ANALYZE

![[image 127.png]]

If we only use EXPLAIN, it does not run the query, while ==**EXPLAIN ANALYZE DOES**==

→ EXPLAIN: tells us what Postgres plans to do but doesn’t actually do it

→ EXPLAIN ANALYZE: tells us what Postgres intend to do and that actually execute it

⇒ Use it for ==**performance evaluation**==

  

![[image 128.png]]

![[image 129.png]]

Each row that has an arrow (->) on them, we refer to as a ==**query node.**==

This is some steps where we are trying to ==**access some data**== that is stored inside the database, or we are trying to ==**do some processing**==.

The very ==**top line**== is technically a query node as well.

The way we read this is by going to the inner most rows. In this case it’s the Index Scan on username index. Every place that has an arrow, it is trying to access some data inside our database or inside of an Index, and then it tries to emit that data or pass that data to the ==**nearest parent**== that has an arrow on it. Purple hash parent is Blue Hash Join, also parent of Seq Scan

  

![[image 130.png]]

==**Hash Join**==: tells us how exactly this particular node or that line is either generating data or processing some data. Here, it’s doing Hash Join operation (join process)

==**Cost**==: tells us the amount of ==**processing power that is required**== for this step

==**Rows**==: estimates how many rows this step right here is going to produce

==**Width**==: estimate of the average number of bytes for each of those rows

  

But if we use EXPLAIN only, it can still calculate the rows and width of the data. But how? Since EXPLAIN doesn’t execute.

→ Postgres does keep some very detailed statistic about what’s going on inside of each different tables

![[image 131.png]]

This allows Postgres to make a guest at some of the different number of rows coming out of each of those steps of the ==**query plan**==

⇒ This stats table is how query planner is able to make a guess about the efficiency, or kind of the cost, or the outcome of each of those different steps without having to do any processing of those steps ahead of time

# Advanced Query Tuning

## Understanding Cost

![[image 132.png]]

![[image 133.png]]

  

The planner will count Page (or Block) needed for each way

![[image 134.png]]

By using index, we are using max 2 Pages, but by fetching all users and search, it might take too 100 pages based on data size.

But there’s something to note about

![[image 135.png]]

Random load takes more time than sequential load!

![[image 136.png]]

  

We can see the pointer jumps all over

![[image 137.png]]

  

### Idea

We want to assume (not accurate) that loading ==**a**== random Page takes 4 times longer than loading up ==**Pages**== sequentially

[](https://www.notion.soundefined)

But still, using Index still faster if there are too many Pages

# Common Table Expression