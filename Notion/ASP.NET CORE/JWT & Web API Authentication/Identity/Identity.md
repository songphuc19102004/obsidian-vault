> **Microsoft [asp.net](http://asp.net) core Identity** is the API to create and manage user accounts in our application

It offers essential mechanism to store, retrieve, validate the users, and also external logins (gmail, facebook,…)

Different roles can access to the particular set of Controllers, Action methods. This is called role-based security or role-based authentication

By default, it supports SQL Server as data source

![[/Untitled 145.png|Untitled 145.png]]

On top of database, we will create identity DB context(Data access layer), so instead of writing raw SQL statement to **connect** with the database, that SQL statement will be auto generated by using the Dbcontext. Identity DbContext is derived(sub-class) of regular DbContext of EF. Based on the Identity DbContext, we have Identity Store(acts as a repository layer). But we are ==not== going to access **Identity Store** in the **Controller,** we need some ==**business logic**== layer to validate the user before inserting or updating,… And the ==BL== is offered as Identity Manager

  

## Creating Models

![[/Untitled 1 27.png|Untitled 1 27.png]]

While working with **[asp.net](http://asp.net) core identity,** we have to commonly used two identity classes. The DbSets are **automatically** created based on these two entity classes: ==**IdentityUser<T>**==, ==**IdentityRole<T>.**==

  

- ==**IdentityUser<T>**== entity class represents the user details(Username, email, password,…), and we can also add properties that are not predefined.
- It is a generic class, <T> represents the data type of the Id(Guid, int, string,…), by default it is a string. Guid is recommended(nearly unlimited).
- The common and formal way to name Identity User entity is : ==**Application**==**User,** ==**Application**==**Role**
- **SecurityStamp**: A random value that must change whenever a user credentials change(Password change, login removed)

  

- ==**IdentityRole<T>**== represents the role of the user(customer, admin, employee,…). We can also add properties that are not predefined.
- <T> represents the data type of the Id.
- For one type of user(Customer, employee,…), one object of IdentityRole is created(1 row in the table)

  

Nuget Packages:

Microsoft.AspNetCore.Identity.EntitiyFrameworkCore: For communication between database and storing identity tables. In other words, to store the user account, like AspNetUser, AspNetRoles,… EFCore is used, along with Identity

![[/Untitled 2 22.png|Untitled 2 22.png]]

![[/Untitled 3 20.png|Untitled 3 20.png]]

==If we have the UI, we will also have to install Microsoft.AspNetCore.Identity.EntitiyFrameworkCore on the project, since we need to add essential services into IOC container from our UI Project==

  

## DB Context

Instead of inheriting from DbContext, we will inherit from IdentityDbConntext<==DataTypeForUser==, ==DataTypeForRole==, ==DataTypeOfUserId==>

```C#
public class ApplicationDbContext : IdentityDbContext<ApplicationUser, ApplicationRole, Guid>
{
...
```

The ==**difference**== between regular DbContext and IdentityDbContext:

- The regular DbContext doesn’t predefined any DbSet
- IdentityDbContext offers the predefined DbSets(tables) that are needed to store the users, roles, and mapping between user and role
- The IdentityDbContext doesn’t know the actual data type used for User and Role, that’s why supply to it
- AspNetRoleClaims(Table): stores additional detail of each role, claim represents additional details, such as admin role has list of pages that it has access to
- AspNetUserClaims(Table) : stores list of claims(additional details) for each user, such as last logged in, status of account(activation),…
- AspNetUserRole(Table): stores role of each user
- AspNetUserTokens(Table): stores tokens, such as OTP password

## Register View

First, create a DTO, in this case, we will create RegisterDTO, which is used to transfer data from view to controller

```C#
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ContactsManager.Core.DTO
{
    public class RegisterDTO
    {
        [Required(ErrorMessage = "Name cant be blank")]
        public string PersonName { get; set; }
        [Required(ErrorMessage = "Email cant be blank")]
        [EmailAddress(ErrorMessage = "Email should be in proper form")]
        public string Email {  get; set; }
        [Required(ErrorMessage = "Phone cant be blank")]
        [RegularExpression("^[0-9]*$", ErrorMessage = "Phone number should contain only numbers")]
        [DataType(DataType.PhoneNumber)]
        public string Phone { get; set; }
        [Required(ErrorMessage = "Password cant be blank")]
        [DataType(DataType.Password)]
        public string Password { get; set; }
        [Required(ErrorMessage = "Confirm Password cant be blank")]
        [DataType(DataType.Password)]
        public string ConfirmPassword { get; set; }
    }
}
```

Based on these ==**DataType**== attribute value, it applies the type attribute value in the input tag in the View  
==The== ==`DataType`== ==attribute in C# is used to provide a hint to the view engine about the type of data being rendered. It is primarily used in ASP.NET MVC applications to help the view engine render the appropriate HTML elements and apply specific formatting or validation rules.==  
==It's important to note that the== ==`DataType`== ==attribute itself does not perform any validation or formatting. It merely serves as a hint to the view engine about the intended data type, allowing it to render the appropriate input controls or apply specific formatting rules.==  
  
**AccountController**

```C#
using ContactsManager.Core.DTO;
using CRUDExample.Controllers;
using Microsoft.AspNetCore.Mvc;

namespace ContactsManager.UI.Controllers
{
    [Route("[controller]/[action]")]
    public class AccountController : Controller
    {

        [HttpGet]
        public IActionResult Register()
        {
            return View();
        }

        [HttpPost]
        public IActionResult Register(RegisterDTO registerDTO)
        {
            //TO-DO: Store user registration details into Identity database
            return RedirectToAction(nameof(PersonsController.Index), "Persons");
        }
    }
}

```

  

## Adding Identity

Before manipulating the users and roles information, we have to add identity as a service to the IOC container

```C#
Program.cs
-----------------
builder.Services.AddIdentity<>();
-----------------

//But since this project is using customer configuration service file
//its still the same as writing in Program.cs

ConfigureServiceExtension.cs
----------------------------
--Since the method is Generic method, we will have to supply the data 
--types of the two classes
----------------------------
services.AddIdentity<ApplicationUser, ApplicationRole>();
```

- By adding the Identity service, you are telling [ASP.net](http://ASP.net) core to store user details using ApplicationUser model, all of the properties defined in the ApplicationUser will be stored in the AspNetUser table(created automatically in the database). Also same with AspNetRole table.
- But that is not enough, we will have to provide more details for the Identity service: Where we have to store this data, using which DbContext

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>()
				.AddEntityFrameworkStores<ApplicationDbContext>;
```

- Now we have to provide the service What is the exact repository layer to use for working with this(this here is ApplicationDbContext), because we cannot use the DbContext directly in the manager class(UserManager class for example)

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddUserStore<UserStore<ApplicationUser, ApplicationRole, 
							    ApplicationDbContext, Guid>>();
```

Explaining: ==services.AddIdentity<ApplicationUser, ApplicationRole>()==: First we have to use ApplicationUser class for creating User table and ApplicationRole class for creating Role table

==AddEntityFrameworkStores<ApplicationDbContext>()==: This is the DbContext to use overall the application

==.AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()==: it is asking us to configure the repository layer(UserStore). “Hey, we have to use UserStore class, with these said classes”.

ApplicationUser: used for storing user details

ApplicationRole: used for storing user details

After that, it will ask us what is the DbContext to use in the UserStore: ==ApplicationDbContext==

Lastly, it asks us what is the data type of User Id

  

```C#
//This is application level
services.AddIdentity<ApplicationUser, ApplicationRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
```

```C#
//This is repository layer level
.AddUserStore<UserStore<ApplicationUser, ApplicationRole, 
							    ApplicationDbContext, Guid>>();
```

But this repository is only for User table, we will have configure one for role as well

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
    .AddRoleStore<RoleStore<ApplicationRole, ApplicationDbContext, Guid>>();
```

![[/Untitled 4 17.png|Untitled 4 17.png]]

We can see the arguments of the RoleStore<>.

Now we have done configuring the Identity Store, which means we don’t need to create custom classes for the store(repository). And also, the User, Role Manager classes, which is the business logic layer, are automatically created

We have to do one more thing: enable the ==**default token provider**==

- Purpose: at the time of login, email and phone number verification or confirmation, generating the forgot password, resetting the password(OTP), we have to generate the random tokens at runtime

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders()
    .AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
    .AddRoleStore<RoleStore<ApplicationRole, ApplicationDbContext, Guid>>();
```

  

## Identity Manager(User Manager, Role Manager)

> Offers the business logic, contains method to manipulate users and roles  
> Inject directly in controller  

### User Manager(UM)

- Provides business logic methods for managing users: creating, searching, updating, deleteing.
- UM internally uses User Store(repository)

  

**Inject to Controller**

```C#
public class AccountController : Controller
{
    private readonly UserManager<ApplicationUser> _userManager;

    public AccountController(UserManager<ApplicationUser> userManager)
    {
        _userManager = userManager;
    }
```

==**ApplicationUser:**== should be the same type of the configuration we made.

  

**Action Method**

```C#
[HttpPost]
public async Task<IActionResult> Register(RegisterDTO registerDTO)
{
    //check validation errors
    if(!ModelState.IsValid)
    {
        ViewBag.Errors = ModelState.Values.SelectMany(temp => temp.Errors).Select(temp => temp.ErrorMessage);
        return View(registerDTO);

    }
    ApplicationUser user = new ApplicationUser()
    {
        Email = registerDTO.Email, 
        PhoneNumber = registerDTO.Phone,
        UserName = registerDTO.Email,
        PersonName = registerDTO.PersonName
    };
    IdentityResult result = await _userManager.CreateAsync(user, registerDTO.Password);
    
   if(result.Succeeded)
	 {
	     return RedirectToAction(nameof(PersonsController.Index), "Persons");
	 }
	 else
	 {
	      foreach(IdentityError error in result.Errors)
	      {
	          ModelState.AddModelError("Register", error.Description);
	      }
	 } 
	  return View(registerDTO);
	 }
```

- ==**IdentityResult**== object represents the result of execution of some particular operation(creating, updating, deleting,…). It contains the status of database operation(successful, failure). In case of failure, it contains the appropriate error message. So we have to check its status.
- As you can see, we don’t initialize password in the ApplicationUser model, but we actually give the password to the CreateAsync() method, it will hash the password(SHA algorithm) for us and store in database.

  

### SignInManager

- Provides business logic methods for sign-in and sign-in functionality of the users(login, logout)
- Provides methods for creating, searching, users
- Firstly, for login purpose, we have 2 methods:
    - SignInAsync(): using when we already have ApplicationUser object
    - PasswordSignInAsync(): using when we ==**don’t have**== ApplicationUser object but we have ==**password and username**==
- SignOutAsync(): Uses to sign out
- IsSignedIn(): Check if user is signed in or not. When ever the user is signed in, it creates cookie automatically in the browser, and that ==**authentication cookie**== will be automatically submitted for all the subsequent requests. For example, when user signed in successfully, ==**AC**== is created in the server side and sent the same to the browser, then the browser store it in the browser memory. When the user navigate to another URL(Ex: /Person/Index), when making the request to the route, the browser will automatically submits the authentication cookie to prove the user is already logged in. Then, the server receive the request and verify if the cookie is valid or not

Moving on from the last code of User Manager, we will automatically login after the account is registered  
  

**Inject to controller**

```C#
public class AccountController : Controller
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly SignInManager<ApplicationUser> _signInManager;

    public AccountController(UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager)
    {
        _userManager = userManager;
        _signInManager = signInManager;
    }
    ...
```

  

**Action Method**

```C#
[HttpPost]
public async Task<IActionResult> Register(RegisterDTO registerDTO)
{
    //check validation errors
    if(!ModelState.IsValid)
    {
        ViewBag.Errors = ModelState.Values.SelectMany(temp => temp.Errors).Select(temp => temp.ErrorMessage);
        return View(registerDTO);

    }
    ApplicationUser user = new ApplicationUser()
    {
        Email = registerDTO.Email, 
        PhoneNumber = registerDTO.Phone,
        UserName = registerDTO.Email,
        PersonName = registerDTO.PersonName
    };
    IdentityResult result = await _userManager.CreateAsync(user);
    //TO-DO: Store user registration details into Identity database
    if(result.Succeeded)
    {
        //sign in
        await _signInManager.SignInAsync(user, isPersistent: true);
        return RedirectToAction(nameof(PersonsController.Index), "Persons");
    }
    else
    {
        foreach(IdentityError error in result.Errors)
        {
            ModelState.AddModelError("Register", error.Description);
        }
    }
    return View(registerDTO);
    
}
```

  

```C#
//sign in
await _signInManager.SignInAsync(user, isPersistent: true);
```

this will create a cookie and send the same to the browser as a part of the response. The “isPersistent” param will decide if the cookie is persistant or not. If it’s true, the cookie will be persisted even after the browser close. If it’s false, the cookie will be deleted after the browser is closed. We can make a check box “keep me signed in” and set **isPersistent** to true if the box is checked. → After register, the user will be logged in.

![[/Untitled 5 14.png|Untitled 5 14.png]]

That means sign out will delete the cookie in the browser memory

  

**Current Working User**

To read the identity cookie, we will have to UseAuthentication() in Program.cs

```C#
app.UseRouting();
app.UseAuthentication();
app.MapControllers();

app.Run();
```

UseAuthentication() ==must== be below of UseRouting()

UseAuthentication() ensures whether the user is logged in or not

![[/Untitled 6 10.png|Untitled 6 10.png]]

![[/Untitled 7 9.png|Untitled 7 9.png]]

using nullable at Identity so that it’s only read when Identity is not null

  

### Password Complexity Configuration

While adding the identity in service, we can configure the password complexity while registering the user

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>(options =>
{
    options.Password.RequiredLength = 8;
    options.Password.RequireNonAlphanumeric = false;
    options.Password.RequireUppercase = false;
    options.Password.RequireLowercase = true;
    options.Password.RequireDigit = false;
    options.Password.RequiredUniqueChars = 3;
})
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders()
    .AddUserStore<UserStore<ApplicationUser, ApplicationRole, ApplicationDbContext, Guid>>()
    .AddRoleStore<RoleStore<ApplicationRole, ApplicationDbContext, Guid>>();
```

The password complexity is checked in the _userManager.CreateAsync(), the IdentityResult result.succeeded will be false, with corresponding validation.

  

### Login Action Method

```C#
[HttpPost]
public async Task<IActionResult> Login(LoginDTO loginDTO)
{
    if(!ModelState.IsValid)
    {
        ViewBag.Errors = ModelState.Values.SelectMany(temp => temp.Errors).Select(temp => temp.ErrorMessage);
        return View(loginDTO);
    }

    var result = await _signInManager.PasswordSignInAsync(loginDTO.Email, loginDTO.Password, isPersistent: false, lockoutOnFailure: false);

    if(result.Succeeded)
    {
        return RedirectToAction(nameof(PersonsController.Index), "Persons");
    }

    ModelState.AddModelError("Login", "Inalid email or password");
    return View(loginDTO);
}
```

==**isPersistent: false**==: he PasswordSignInAsync() will also create identity cookie and this attribute will decide whether the identity cookie is persistant or not

  

==**lockoutOnFailure: true(false)**== **:** This means, if user tries to make ==more than 3== attempts of failure(invalid username or password), then ==lock out== that ==account== from login ==for a while==

  

### Logout action method

Simply, when we log out, the identity cookie will be removed

```C#
public async Task<IActionResult> Logout()
{
    await _signInManager.SignOutAsync();
    return RedirectToAction(nameof(PersonsController.Index), "Persons");
}
```

SignOutAsync(): it adds a response header saying that “clear cookie”, so the browser is instructed to delete the cookie

  

## Authorization Policy

If request doesn’t have identity cookie, which means the user is not logged in, then some pages will not be accessible.

We will add UseAuthorization() between UseAuthentication() and MapControllers():

```C#
app.UseRouting(); //Identifying action method based on route
app.UseAuthentication(); //Reading Identity cookie
app.UseAuthorization();
app.MapControllers(); //Execute the filter pipiline (action + filters)

app.Run();
```

- It evaluates whether the current user has permission to access the particular resource or not. By default, we will restrict the access to all the action method of all the controllers in the entire application, but we will allow the action method of AccountController(login, register,…) by using AllowAnonymous filter. Therefore, [AllowAnonymous] should be put on the AccountController.
- UseAuthorization() validates access permissions of the user

Add options:

```C#
services.AddAuthorization(options =>
{
    options.FallbackPolicy = new AuthorizationPolicyBuilder()
														    .RequireAuthenticatedUser()
														    .Build();
});
```

- It enforces authorization policy, means authorization filter for all action methods
- This means, all the action method can only be used on authorized user(logged in), which means request must have identity cookie