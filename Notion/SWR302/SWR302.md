  

**Reuse opportunity**

![[/Untitled 38.png|Untitled 38.png]]

  

![[/Untitled 1 5.png|Untitled 1 5.png]]

![[/Untitled 2 4.png|Untitled 2 4.png]]

  

**effect of requirement**

→ drive iteration

![[/Untitled 3 4.png|Untitled 3 4.png]]

  

CRUD matrix → detect missing reqs

![[/Untitled 4 3.png|Untitled 4 3.png]]

  

Prototype

![[/Untitled 5 3.png|Untitled 5 3.png]]

  

User personas

hypothetical, generic person

  

Checklist: co truoc → Predefined

  

use case: trang 614

![[/Untitled 6 2.png|Untitled 6 2.png]]

  

A mock-up is also called a horizontal prototype.

  

Disagreement

![[/Untitled 7 2.png|Untitled 7 2.png]]

![[/Untitled 8 2.png|Untitled 8 2.png]]

![[/Untitled 9 2.png|Untitled 9 2.png]]

![[/Untitled 10 2.png|Untitled 10 2.png]]

  

![[/Untitled 11 2.png|Untitled 11 2.png]]

  

Action enablers: (171)

![[/Untitled 12 2.png|Untitled 12 2.png]]

  

![[/Untitled 13 2.png|Untitled 13 2.png]]

  

Find voice of user:

![[/Untitled 14 2.png|Untitled 14 2.png]]

  

srs va br khac nhau

![[/Untitled 15 2.png|Untitled 15 2.png]]

![[/Untitled 16 2.png|Untitled 16 2.png]]

![[/Untitled 17 2.png|Untitled 17 2.png]]

![[/Untitled 18 2.png|Untitled 18 2.png]]

  

![[/Untitled 19 2.png|Untitled 19 2.png]]

![[/Untitled 20 2.png|Untitled 20 2.png]]

![[/Untitled 21 2.png|Untitled 21 2.png]]

![[/Untitled 22 2.png|Untitled 22 2.png]]

![[/Untitled 23 2.png|Untitled 23 2.png]]

![[/Untitled 24 2.png|Untitled 24 2.png]]

  

![[/Untitled 25 2.png|Untitled 25 2.png]]

![[/Untitled 26 2.png|Untitled 26 2.png]]

![[/Untitled 27 2.png|Untitled 27 2.png]]

  

![[/Untitled 28 2.png|Untitled 28 2.png]]

  

![[/Untitled 29 2.png|Untitled 29 2.png]]

  

![[/Untitled 30 2.png|Untitled 30 2.png]]

  

Prototype purposes:

![[/Untitled 31 2.png|Untitled 31 2.png]]

  

![[/Untitled 32 2.png|Untitled 32 2.png]]

  

![[/Untitled 33 2.png|Untitled 33 2.png]]

  

![[/Untitled 34 2.png|Untitled 34 2.png]]

  

![[/Untitled 35 2.png|Untitled 35 2.png]]

  

least helpful: observations

  

![[/Untitled 36 2.png|Untitled 36 2.png]]

  

![[/Untitled 37 2.png|Untitled 37 2.png]]

  

![[/Untitled 38 2.png|Untitled 38 2.png]]

  

![[Untitled 39.png]]

  

==**Requirements analysis (requirements engineering)**==

![[Untitled 40.png]]

  

![[Untitled 41.png]]

**→ Trước khi khai thác thì chuẩn bị câu hỏi, sau đó thực hiện khai thác, sau khai thác(follow up after elicitation) thì organizze and share notes, cuối cùng là document open issues**

  

![[Untitled 42.png]]

  

Contextual inquiry: observe users in their natural environment

  

interview technique

![[Untitled 43.png]]

  

==**not**== purpose of state-transition diagram → keyword = diagram → ko phải ==**big picture**==

  

decompose → Manual reqeuirements

![[Untitled 44.png]]

  

![[Untitled 45.png]]

  

inspection: formal

walkthrough: informal

  

signal that you complete requirement elicitation

![[Untitled 46.png]]

  

![[Untitled 47.png]]

![[Untitled 48.png]]

  

![[Untitled 49.png]]

![[Untitled 50.png]]

keywords

background: rationale

business opportunity: being solved

business objective: quantitative and measurable

success metric: measure succes

vision statement: long-term purpose

business risk: major business risk

  

  

![[Untitled 51.png]]

  

requirement status

![[Untitled 52.png]]

  

Requirement attributes

![[Untitled 53.png]]

  

Change control board charter (CCB Charter) includes:

- Making decisions
- Communicating status

  

15-18%

![[Untitled 54.png]]

  

turn risk information into decisions and actions → Plan

![[Untitled 55.png]]

  

perform elicitation

![[Untitled 56.png]]

  

Đề sẽ ra câu “management agree…” ==**ở dạng phủ định**== → chỉ chọn testers agree, ko chọn both

![[Untitled 57.png]]

  

![[Untitled 58.png]]

  

use case term:

![[Untitled 59.png]]

user story:

![[Untitled 60.png]]

  

identify user class

![[Untitled 61.png]]

  

Motivations for tracing requirements:

![[Untitled 62.png]]

  

**Books taller than 16 inches are shelved in the library's Oversize section:** ==**is a FACT**==**,** ==**NOT A CONSTRAINT**==

  

![[Untitled 63.png]]

  

  

When done requirement elicitation

![[Untitled 64.png]]

  

requirement baseline

![[Untitled 65.png]]

  

→ Objectives first then success metrics → true

![[Untitled 66.png]]

  

![[Untitled 67.png]]

  

ecosystem map

![[Untitled 68.png]]

  

![[Untitled 69.png]]

  

COTS(commercial off the shell)

![[Untitled 70.png]]

  

None of the others

![[Untitled 71.png]]

  

Context diagram

![[Untitled 72.png]]

  

procress assets

![[Untitled 73.png]]

  

amount of work of packaged solution

![[Untitled 74.png]]

  

domain-specific

![[Untitled 75.png]]

  

Verification(thing right)

![[Untitled 76.png]]

![[Untitled 77.png]]

  

Validation(right thing)

![[Untitled 78.png]]

![[Untitled 79.png]]

  

formula of priority

![[Untitled 80.png]]

  

Common application features

![[Untitled 81.png]]

  

reuse opportunities

![[Untitled 82.png]]

  

BPM: encompass

BPI: keyword: incremental

![[Untitled 83.png]]

  

CRUD matrix: keyword: mising requirements

![[Untitled 84.png]]

  

Ambigous term and ways to improve them(Page 214 and slide 248)

![[Untitled 85.png]]

![[Untitled 86.png]]

![[Untitled 87.png]]

![[Untitled 88.png]]

Just remeber 4 of those

  

**According to Karl Wiegers and Joy Beatty in Software Requirements 3rd Edition, prioritization requirements process**

![[Untitled 89.png]]

  

  

System architecture core elements

![[Untitled 90.png]]

![[Untitled 91.png]]

  

Begin from slides page 121, slide 154, about interviews, workshop,…

**Interviews:**

- Establish rapport
- Stay in scope
- Prepare questions and straw man models ahead of time
- Suggest ideas
- Listen actively

  

Begin from page 543, slide 576

![[Untitled 92.png]]

  

requirement developement process

![[Untitled 93.png]]

  

Requirement engineering

1. Req **elicitation**
2. Req **analysis**
3. Req **specification**
4. Req **validation**
5. Req **management**

→ 1,2,3,4 giống cái process framework, thêm chữ requirement, cái 5 là management

  

assumption

![[Untitled 94.png]]

  

giảm **1/3**

![[Untitled 95.png]]

  

usage-centric

![[Untitled 96.png]]

![[Untitled 97.png]]

  

product-centric

![[Untitled 98.png]]

![[Untitled 99.png]]

  

Business requirement section

![[Untitled 100.png]]

![[Untitled 101.png]]

  

How to classify user into groups

![[Untitled 102.png]]

  

D is wrong because it’s a way to find the voice of user

![[Untitled 103.png]]

  

Industry-standard term, **exchangeable**

**srs**

  

Customer definition

![[Untitled 104.png]]

  

**User req**

==**General statements**== of user goals or business tasks that users need to perform are user requirements, most typically represented as use cases, scenarios, or user stories (see Chapter 8, “Understanding user requirements”). A user who says, “I need to <do something>” is probably describing a user requirement, as in the following examples

![[Untitled 105.png]]

  

  

**Business requirements**

Anything that describes the ==**financial, marketplace**==, or other ==**business benefit**== that either customers or the developing organization wish to gain from the product is a business requirement (see Chapter 5). Listen for statements about the value that buyers or users of the software will receive, such as these:  
■“Increase market share in region X by Y percent within Z months.”  
■“Save $X per year on electricity now wasted by inefficient units.”  

  

**Business rules**

When a customer says that ==**only certain users can perform an activity under specific conditions**==, he might be presenting a business rule (see Chapter 9, “Playing by the rules”). These aren’t software requirements as they stand, but you might derive some functional requirements to enforce the rules. Phrases such as “Must ==**comply**== with . . . ,” “==**If**== <some condition is true>, then <something happens>,” or “Must be calculated according to . . . ” suggest that the user is describing a business rule. Here are some examples:  
■“A ==**new client**== must pay 30 percent of the estimated consulting fee and travel expenses in advance.”  
■“Time-off approvals must ==**comply**== with the company’s HR vacation policy.”

  

**Functional requirements**

Functional requirements describe the observable behaviors the system will exhibit under certain conditions and the actions the system will let users take. Here are some examples of functional requirements as you might hear them from users:  
■“If the pressure exceeds 40.0 psi, the high-pressure warning light should come on.”  
■“The user must be able to sort the project list in forward and reverse alphabetical order.”  

  

**Quality attributes** ==**(non functional)**==

Statements that describe how well the system does something are quality attributes (see Chapter 14, “Beyond functionality”). Listen for words that describe desirable system characteristics: fast, easy, user-friendly, reliable, secure. You’ll need to work with the users to understand just what they mean by these ambiguous and subjective terms so that you can write clear, verifiable quality goals. The following examples suggest what quality attributes might sound like when described by users:  
■“The mobile software must respond quickly to touch commands.”  
■“The shopping cart mechanism has to be simple to use so my new customers don’t abandon the purchase.  

  

**External interface requirements**

Requirements in this category describe the connections between your system and the rest of the universe. The SRS template in Chapter 10, “Documenting the requirements,” includes sections for interfaces to users, hardware, and other software systems. Phrases such as “==**Must**== read signals from . . . ,” “Must send messages to . . . ,” “==**Must**== be able to read files in <format>,” and “User interface elements ==**must**== conform to <a standard>” indicate that the customer is describing an external interface requirement. Following are some examples:  
■“The manufacturing execution system must control the wafer sorter.”  
■“The mobile app should send the check image to the bank after I photograph the check I’m depositing.”  

  

**Constraints**

Design and implementation constraints legitimately restrict the options available to the developer (see Chapter 14). Devices with embedded software often must respect physical constraints such as size, weight, and interface connections. Phrases that indicate that the customer is describing a design or implementation constraint include: “==**Must**== be written in <a specific programming language>,” “Cannot exceed <some limit>,” and “Must use <a specific user interface control>.” The following are examples of constraints that a customer might present:busines  
■“Files submitted electronically cannot exceed 10 MB in size.”  
■“The browser must use 256-bit encryption for all secure transactions.”  

  

BA role

![[Untitled 106.png]]

keyword: disseminating, communicating

  

sign-off

![[Untitled 107.png]]

keyword: mark of approval

  

market segment

![[Untitled 108.png]]

  

Characteristics of requirement statements  
In an ideal world, every individual business, user, functional, and nonfunctional requirement would exhibit the qualities described in the following sections.  
==**Complete**==  
Each requirement must contain all the information necessary for the reader to understand it. In the case of functional requirements, this means providing the information the developer needs to be able to implement it correctly. If you know you’re lacking certain information, use TBD (to be determined) as a standard flag to highlight these gaps, or log them in an issue-tracking system to follow up on later. Resolve all TBDs in each portion of the requirements before the developers proceed with construction of that portion.  
==**Correct**==  
Each requirement must accurately describe a capability that will meet some stakeholder’s need and must clearly describe the functionality to be built. You’ll have to go to the source of the requirement to check its correctness. This might be a user who supplied the initial requirement, a higher-level system requirement, a use case, a business rule, or another document. A low-level requirement that conflicts with its parent is not correct. To assess the correctness of user requirements, user representatives or their close surrogates should review them.  
==**Feasible**==  
It must be possible to implement each requirement within the known capabilities and limitations of the system and its operating environment, as well as within project constraints of time, budget, and staff. A developer who participates during elicitation can provide a reality check on what can and cannot be done technically and what can be done only at excessive cost or effort. Incremental development approaches and proof-of-concept prototypes are two ways to evaluate requirement feasibility. If a requirement needs to be cut because it is not be feasible, understand the impact on the project vision and scope.  
==**Necessary**==  
Each requirement should describe a capability that provides stakeholders with the anticipated business value, differentiates the product in the marketplace, or is required for conformance to an external standard, policy, or regulation. Every requirement should originate from a source that has the authority to provide requirements. Trace functional and nonfunctional requirements back to specific voice-of-the-user input, such as a use case or user story. You should be able to relate each  
requirement to a business objective that clearly indicates why it’s necessary. If someone asks why a particular requirement is included, there should be a good answer.  
==**Prioritized**==  
Prioritize business requirements according to which are most important to achieving the desired value. Assign an implementation priority to each functional requirement, user requirement, use case flow, or feature to indicate how essential it is to a particular product release. If all requirements are equally important, the project manager doesn’t know how best to respond to schedule overruns, personnel losses, or new requirements that come along. Requirements prioritization should be a collaborative activity involving multiple stakeholder perspectives. Chapter 16, “First things first: Setting requirement priorities,” discusses prioritization in further detail.  
==**Unambiguous**==  
Natural language is prone to two types of ambiguity. One type I can spot myself, when I can think of more than one way to interpret a given requirement. The other type of ambiguity is harder to catch. That’s when different people read the requirement and come up with different interpretations of it. The requirement makes sense to each of them but means something different to each of them. Inspections are a good way to spot ambiguities (Wiegers 2002). A formal peer review such as an inspection (as opposed to just passing out the requirements to individuals to examine on their own) provides an opportunity for each participant to compare his understanding of each requirement to someone else’s. “Comprehensible” is related to “unambiguous”: readers must understand what each requirement is saying. Chapter 17 describes the software peer review process.  
You’ll never remove all the ambiguity from requirements—that’s the nature of human language. Most of the time, reasonable people can draw the right conclusions from even a slightly fuzzy requirement. Getting a little help from your colleagues through reviews will clean up a lot of the worst issues, though.  
==**Verifiable**==  
Can a tester devise tests or other verification approaches to determine whether each requirement is properly implemented? If a requirement isn’t verifiable, deciding whether it was correctly implemented becomes a matter of opinion, not objective analysis. Requirements that are incomplete, inconsistent, infeasible, or ambiguous are also unverifiable. Testers are good at examining requirements for verifiability. Include them in your requirements peer reviews to catch problems early  

  

External: observable by users or stakeholders

Internal: relevant to devs

![[Untitled 109.png]]

  

==**Throwaway prototype(one time prototype)**==

A throwaway prototype is most appropriate when the team faces uncertainty, ambiguity, incompleteness, or vagueness in the requirements, or when they have difficulty envisioning the system from the requirements alone.

  

  

![[Untitled 110.png]]

  

  

common challange of packaged solution: user reject solution

  

![[Untitled 111.png]]

  

## **Plan-driven → uses standardized templates**

  

not a signal that indicate complete elicitation

![[Untitled 112.png]]

  

  

![[Untitled 113.png]]